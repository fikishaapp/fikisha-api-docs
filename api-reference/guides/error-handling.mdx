---
title: 'Error Handling'
description: 'Comprehensive guide to handling errors from the Fikisha Vendor API.'
---

import { Tip } from "mintlify/components";

# Error Handling

The Fikisha Vendor API uses standard HTTP status codes and a consistent JSON error format to indicate problems with your API requests. This guide will help you implement robust error handling for your integration.

## Error Response Structure

All API errors follow a consistent JSON format:

```json
{
  "success": false,
  "error": "Error Type",
  "message": "A human-readable description of the specific error encountered."
}

success: Always false for error responses.
error: A type identifier for the error category, useful for programmatic handling.
message: A clear explanation of the problem intended for developers. This message may not be suitable for direct display to end-users.

HTTP Status Codes
The API uses conventional HTTP status codes to indicate the general category of response:
2xx Success

200 OK: The request was successful (typical for most requests).
201 Created: The resource was successfully created (sometimes used for POST requests).
202 Accepted: The request was accepted for processing (for some asynchronous operations).

4xx Client Errors

400 Bad Request: The request was malformed, contained invalid parameters, or was missing required fields.
401 Unauthorized: Authentication failed. Your X-Vendor-ID or X-API-Key header is missing, invalid, or deactivated.
403 Forbidden: Authentication successful, but you lack permission for the requested resource or action.
404 Not Found: The requested endpoint or resource could not be found.
429 Too Many Requests: You've exceeded the API rate limits. Implement exponential backoff and retry logic.

5xx Server Errors

500 Internal Server Error: An unexpected error occurred on the Fikisha server.
502 Bad Gateway: Error communicating with an upstream service or payment provider.
503 Service Unavailable: The API or a required service is temporarily unavailable (e.g., during maintenance).
504 Gateway Timeout: A timeout occurred while waiting for a response from an upstream service.

Common Error Types
The API uses specific error values in the error response to provide more detail about the error type. Here's a list of common error types you may encounter:
Error TypeDescriptionHTTP StatusAuthentication RequiredMissing or invalid API credentials.401Invalid RequestGeneric validation error (missing fields, invalid format).400Not FoundRequested resource not found.404ForbiddenInsufficient permissions for the requested operation.403Internal Server ErrorAn unexpected server-side error.500
Error Handling Best Practices
<Tip>
  Always check both the HTTP status code and the error type in the response body to make your error handling as robust as possible.
</Tip>
1. HTTP Status Code-Based Handling
javascriptasync function makeApiRequest(endpoint, options) {
  try {
    const response = await fetch(`https://api.fikisha.app/v1${endpoint}`, options);

    const data = await response.json();

    // Check for success flag
    if (data.success === true) {
      return data.data;
    }

    // Handle error based on status code
    switch (response.status) {
      case 401:
        console.error('Authentication failed:', data.message);
        // Handle authentication error (e.g., refresh credentials)
        break;
      case 400:
        console.error('Invalid request:', data.message);
        // Handle validation errors
        break;
      case 404:
        console.error('Resource not found:', data.message);
        // Handle not found errors
        break;
      case 429:
        console.error('Rate limit exceeded:', data.message);
        // Implement backoff strategy
        break;
      case 500:
      case 502:
      case 503:
      case 504:
        console.error('Server error:', data.message);
        // Handle server errors
        break;
      default:
        console.error(`Unknown error (${response.status}):`, data.message);
    }

    throw new Error(data.message);
  } catch (error) {
    // Handle network errors or JSON parsing errors
    console.error('Request failed:', error);
    throw error;
  }
}
2. Error Type-Based Handling
For more specific handling, you can use the error value from the error response:
javascriptasync function handleApiError(errorResponse) {
  const { error, message } = errorResponse;

  switch (error) {
    case 'Authentication Required':
      // Prompt for re-authentication
      showAuthenticationPrompt();
      break;

    case 'Invalid Request':
      // Show validation errors to the user
      displayValidationErrors(message);
      break;

    case 'Not Found':
      // Handle resource not found
      showNotFoundMessage();
      break;

    case 'Forbidden':
      // Handle permission issues
      showPermissionDeniedMessage();
      break;

    case 'Internal Server Error':
      // Log the error and show a friendly message
      logServerError(message);
      showServerErrorMessage();
      break;

    default:
      // Handle unknown error types
      showGenericErrorMessage(message);
  }
}
3. Implementing Retry Logic
For transient errors (like rate limiting or temporary service unavailability), implement an exponential backoff strategy:
javascriptasync function makeApiRequestWithRetry(endpoint, options, maxRetries = 3) {
  let retryCount = 0;

  while (retryCount < maxRetries) {
    try {
      return await makeApiRequest(endpoint, options);
    } catch (error) {
      // Only retry on rate limits or server errors
      const isTransientError =
        error.status === 429 ||
        error.status === 503 ||
        error.status === 504;

      if (!isTransientError || retryCount >= maxRetries - 1) {
        throw error; // Don't retry non-transient errors or if max retries reached
      }

      // Exponential backoff
      const delayMs = Math.pow(2, retryCount) * 1000 + Math.random() * 1000;
      console.log(`Retrying after ${delayMs}ms...`);
      await new Promise(resolve => setTimeout(resolve, delayMs));

      retryCount++;
    }
  }

  throw new Error(`Failed after ${maxRetries} retries`);
}
4. Handling Asynchronous Operation Status
For operations that are processed asynchronously, use webhook notifications or poll for status updates:
javascript// Option 1: Implement webhook handler
function handleWebhook(req, res) {
  const signature = req.headers['fikisha-signature'];
  const payload = req.body;

  // 1. Validate webhook signature
  if (!isValidSignature(payload, signature, WEBHOOK_SECRET)) {
    return res.status(401).send('Invalid signature');
  }

  // 2. Send immediate 200 response to acknowledge receipt
  res.status(200).send('Webhook received');

  // 3. Process the webhook asynchronously
  processWebhookAsync(payload).catch(error => {
    console.error('Error processing webhook:', error);
  });
}

async function processWebhookAsync(payload) {
  const { eventType, data } = payload;

  switch (eventType) {
    case 'transaction.completed':
      await handleCompletedTransaction(data);
      break;
    case 'transaction.failed':
      await handleFailedTransaction(data);
      break;
    // Handle other event types
  }
}

// Option 2: Poll for status
async function checkTransactionStatus(transactionId, maxAttempts = 10) {
  let attempts = 0;

  while (attempts < maxAttempts) {
    try {
      const result = await makeApiRequest(
        `/transactions/${transactionId}`,
        {
          method: 'GET',
          headers: getAuthHeaders()
        }
      );

      if (result.status === 'completed') {
        return result; // Success!
      } else if (result.status === 'failed') {
        throw new Error(`Transaction failed: ${result.failureReason || 'Unknown reason'}`);
      }

      // Still processing, wait and retry
      console.log(`Status: ${result.status}, attempt ${attempts + 1}/${maxAttempts}`);

      // Increase delay between retries
      const delayMs = Math.min(30000, 2000 * Math.pow(1.5, attempts));
      await new Promise(resolve => setTimeout(resolve, delayMs));

      attempts++;
    } catch (error) {
      // Handle API errors during polling
      console.error(`Error checking status for request ${transactionId}:`, error);
      throw error;
    }
  }

  throw new Error(`Timeout waiting for transaction ${transactionId} to complete after ${maxAttempts} attempts`);
}
By implementing these error handling patterns in your integration, you'll create a more robust application that can gracefully handle API errors, automatically recover from transient failures, and provide meaningful feedback to your users.
```
